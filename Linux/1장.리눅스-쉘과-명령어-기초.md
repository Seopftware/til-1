# 1장. 리눅스 쉘과 명령어 기초
## 리눅스와 쉘
- 쉘(Shell) : 운영체제에서 제공하는 명령을 실행하는 프로그램이며 운영체제의 관리하에 있는 파일, 프린팅, 하드웨어 장치, 애플리케이션과의 인터페이스를 제공한다
- 즉, 운영 체제에서 제공하는 각종 명령들을 쉘 인터페이스에서 실행하면 운영체제가 그 명령에 해당하는 일을 수행
- 쉘 스크립트 : 인터프리터로서 리눅스 시스템에서 지원하는 명령어들의 집합을 묶어서 프로그램화한 것

```
du -h * | sort -nr > $HOME/script.txt
```
- du : 용량을 알아보기 위한 명령어
- ```|``` : 결과값을 다음 명령으로 연결해 다음 명령의 아규먼트로 사용
- sort : 알파벳 또는 숫자 기준으로 정렬. -n : 숫자값을 기준으로 정렬, -r : 반대의 순서(내림차순)
- ```>``` : 리다이렉션은 앞의 명령 결과를 다음에 나오는 파일명으로 저장

- 리눅스 bash 쉘에서 ```$``` 표시는 일반유저의 쉘을 의미하고 ```#``` 표시는 root 유저의 쉘을 의미함


- 쉘 스크립트를 작성할 때 스크립트의 최상단에 본 쉘인 경우 ```#!/bin/sh```, 배시 쉘인 경우 ```#!/bin/bash```, 파이썬일 경우 ```#!/bin/python``` 와 같이 실행할 언어를 지정해야 한다

- ```which 명령어```는 환경 변수에 지정된 PATH 변수의 경로 내에서 실행 파일의 이름을 검색하고자 할 때 사용
- ```whereis```는 명령의 실행 파일, 소스, 맨페이지의 위치를 검색하는 명령


## 리눅스 환경
- 리눅스는 핀란드 헬싱키 대학의 학생이었던 리누스 토발즈의 취미 생활로 탄생

### 리눅스의 특징
- Free
	- OS 구입에 따른 비용을 지출하지 않아도 됨 
- Unix Like
	- 유닉스처럼 리눅스는 C 언어로 작성됨
	- 유닉스처럼 리눅스는 멀티유저/멀티태스킹을 지원하는 네트워크 OS
	- 유닉스처럼 리눅스는 프로그래밍 개발환경에 매우 적합
	- 유닉스처럼 다양한 하드웨어 플랫폼을 지원
		- Intel x86 processor
		- Macintosh PC
		- Cyrix processor
		- AMD processor
		- Sun Microsystems Sparc processor
		- Alpha Processor(Compaq)
- Open Source
- 그 외에 안정성, 강건성, 보안성, 높은 성능 등의 특징도 존재

### 리눅스 파일 시스템
- 리눅스에서 최상위(root) 디렉터리는 ```/```로 표시하고 그 하위에 ```/root```, ```/usr```, ```/etc```, ```/boot```, ```/tmp``` 등으로 구분하며, 각 디렉터리들은 파티션으로 구성될 수 있음. 하나의 파티션이 하나의 디렉터리가 될 수 있음
- 파티션을 디렉터리에 매칭시키기 위해서 ```mount```라는 개념을 사용
- ```/dev``` 디렉터리는 여러 가지 디바이스 관련 파일이 있는 디렉터리
- ```/dev/null``` 파일은 어떤 문자를 이 장치로 보내면 문자를 모두 지워버림
- ```/dev/zero``` 파일은 새로운 파일을 생성할 때 0으로 채우기 위해 사용
- ```/dev/tty``` : 프로그램이 실행되고 있는 터미널 윈도우 또는 콘솔
- ```/dev/dsp``` : 사운드 카드에 AU 사운드 파일을 실행하는 인터페이스
- ```/dev/fd0``` : 첫 플로피 드라이버
- ```/dev/hda1``` : IDE 하드 디스크의 첫 파티션. hda2 처럼 하나의 하드 디스크에 여러개릐 파티션을 구성할 수 있음
- ```/dev/sda1``` : SCSI, S_ATA 하드 디스크의 첫 파티션
- /dev/hda1 파티션을 /backup 디렉터리에 마운트 하려면 아래와 같이 입력
```
sudo mount -t ext3 /dev/hda1 /backup
```

## 쉘 스크립트 준비운동
- 쉘 : 키보드로부터 명령을 입력받아 OS가 그 명령을 수행하도록 하는 프로그램
- CLI, GUI를 가지고 있음
- 리눅스에서 사용할 수 있는 쉘의 종류를 확인하려면 ```/etc/shells``` 파일을 출력해보면 된다 : ```cat /etc/shells```
- Bash : 리눅스에 기본 탑재된 일반적인 쉘로 sh 본 쉘과 호환되기 때문에 대부분 sh와 bash에서 모두 작동
- ```echo``` : 뒤이어 입력되는 문자열을 모니터로 출력 (print)
- 리눅스의 모든 환경 변수는 대문자로 구성되어 있음
- ```env``` : 환경 변수 출력

### 쉘 스크립트 구성요소
- if ~ else와 fore, while 등의 쉘 루프 명령어
- grep, awk, cut 등의 텍스트 처리 유틸
- w, who, free 등의 바이너리 명령어

### 쉘 스크립트를 사용하는 이유
- 쉘 스크립트는 유저 또는 파일로부터 입력을 받아 모니터에 데이터를 출력
- 동일한 작업을 반복하여 수행하고자 할 때 자동화할 수 있다
- 시간을 절약할 수 있음
- 자신만의 파워툴, 파워 유틸리티를 만들 수 있음
- 관리자 작업을 커스터마이징 할 수 있음
- 서비스 환경 설정과 유저 추가와 같은 작업에서 에러를 줄일 수 있음
- 실제적인 쉘 스크립트 사용 예는 다음과 같음
	- 리눅스 시스템 모니터링
	- **데이터 백업과 스냅샷 생성**
	- **Oracle, MySQL 데이터베이스 백업을 위한 덤프 작업**
	- 시스템 경고메세지를 이메일로 받기
	- 시스템 리소스를 잡아먹는 프로세스 찾아내기
	- 여유 메모리와 사용량 찾아내기 
	- 로그인한 모든 유저와 현재 무엇을 하고 있는지 찾아내기
	- 네트워크 서비스가 정상적인지 아닌지 알아보기
	- 모든 실패한 로그인 정보 찾아내기
	- 보안 정책에 따른 유저 관리
	- BIND의 서버 환경에서 zone 엔트리 추가
- 쉘 스크립트를 사용하면 안될때 (프로그래밍 언어를 사용해야 할 경우)
	- 리소스에 민감한 작업들, 특히 속도가 중요한 요소일 때(정렬, 해쉬 등) 
	- 강력한 산술 연산 작업들, 특히 임의의 정밀도 연산이나 복소수를 써야할 때(C++)
	- 플랫폼 간 이식성이 필요할 때(C)
	- 구조적 프로그래밍이 필요한 복잡한 복잡한 애플리케이션
	- 업무에 아주 중요하거나 회사의 미래가 걸렸단 확신이 드는 애플리케이션
	- 보안상 중요해서 시스템 무결성을 보장하기 위해 외부의 침입이나 크래킹, 파괴 등을 막아야 할 필요가 있을 때
	- 서로 의존적인 관계에 있는 여러 컴포넌트로 이루어진 프로젝트
	- 과도한 파일 연산이 필요할 때(Bash 쉘은 제한적인 직렬적 파일 접근을 하고, 특히 불편하고 불충분한 줄 단위 접근만 가능)
	- 다차원 배열이 필요할 때
	- 링크드 리스트나 트리 같은 데이터 구조가 필요할 때
	- 그래픽이나 GUI를 만들고 변경하는 등의 작업이 필요할 때
	- 시스템 하드웨어에 직접 접근해야할 때
	- 포트나 소켓 IO가 필요할 때
	- 예전에 쓰던 코드를 사용하는 라이브러리나 인터페이스를 써야할 필요가 있을 때
	- 독점적이고 소스 공개를 안하는 애플리케이션을 만들어야 할 때
- ```man``` : 도움말 매뉴얼을 출력하는 명령어
	- 한글로 보고싶다면 ```LANG=ko_KR.UTF8```을 실행

### 리눅스 기본 명령어들의 형식
- 리눅스에서 환경 변수를 제외한 거의 모든 명령어들은 소문자로 구성되어 있으며, 윈도우와 달리 대소문자를 구분
- ```date``` 입력하면 날짜가 나오는데, ```date '+%H:%M'```을 입력하면 해당 포맷으로 변경. ```-u``` 옵션을 주면 UTC 시간이 출력

### 다중 명령어 사용
- 하나의 라인에서 여러 개의 명령을 실행하려면 하나의 명령 다음에 ```;```를 추가해 명령이 끝났음을 지정해주면 됨. 
	- 단, 첫 명령이 실패해도 두번째 명령은 반드시 실행됨
- ```&&```를 명령어 사이에 붙이면 첫 명령이 정상적으로 종료했을 경우에만 두 번째 명령을 수행함
- ```||```를 붙이면 각각의 모든 명령을 수행

### 명령 히스토리
- ```history```에 최근 실행한 명령들이 저장되어 있음
- 최근 실행한 명령을 다시 실행하기 위해 ```!```을 사용. 다음에 매칭되는 문자를 최근 명령에서 찾아서 실행
	- -1같이 마이너스 숫자를 지정할 경우 최근 명령부터 숫자만큼의 명령을 실행
- ```!!```을 사용하면 가장 최근 명령어를 다시 실행

### 리눅스 디렉터리 여행
- ```pwd``` : 현재 디렉터리 위치 보기
- ```ls``` : 파일과 디렉터리 목록 보기
	- ```ls -l```로 출력된 컬럼의 의미는 아래와 같음
	- [파일/디렉터리 퍼미션][하드 링크파일 수][소유자][그룹][파일 크기][수정 시간][파일명] 
- ```cd``` : 현재 쉘의 디렉터리 변경, 이동
- ```less```, ```more```, ```cat``` : 텍스트 파일 보기
	- less는 q를 누르면 원래 셀 위치의 다음 라인으로 돌아오고, more는 q를 누르면 원래 쉘 위치로 돌아오지 않음, cat은 쉘 프롬포트를 리턴
- ```file``` : 파일 타입 보기
- ```tree``` : 디렉터리의 트리 구조 print
	- ```-d``` : 디렉터리만 / ```-a``` : 모든 것 / ```-f``` : 파일만 / ```-L``` : 디렉터리 깊이 지정
	- ```tree -L1 /``` : 최상위 root(/) 부터 깊이가 1인 디렉터리와 파일 출력
	 
### 파일/디렉터리 퍼미션
- 파일에 대한 접근 권한을 설정하는 것으로 ```-``` 문자는 일반 파일, ```d``` 문자는 디렉터리, ```c``` 문자는 캐릭터 디바이스, ```b```는 블록 디바이스, ```l``` 은 심볼릭 링크 파일, ```s```는 소켓 파일을 의미. 그 다음 3개의 문자 단위는 파일 소유자의 read, write, execution, 그룹의 read, write, execution, 모든 사용자의 read,write,execution을 표시

### 하드 링크 파일 수
- 하드 링크 : 리눅스상에서 동일한 파일시스템 내의 파티션에서 동일한 inod 정보를 가지는 파일
- ```ln 원본파일 하드링크파일명``` 명령을 사용해 하나의 링크 파일을 생성하면 원본 파일고 ㅏ하드 링크 파일은 동일한 inode 정보를 가지게 되고, 어느 하나의 파일이 변경되면 두 파일 모두 동일한 내용과 크기로 변경
- 심볼릭 링크 : ```ln -s 원본파일 심볼릭링크파일명```을 사용하며 원본 파일의 이름만 링크. 원본 파일을 삭제하면 심볼릭 링크 파일은 가리킬 파일명이 삭제되었기 때문에 의미없는 파일이 됨	
	
### 리눅스 기본 디렉터리 구성	
- ```/``` : 루트 디렉터리
- ```/boot``` : 리눅스 커널과 부트로더가 위치하는 디렉터리
- ```/etc``` : 시스템 환경 설정 파일이 위치한 디렉터리
	- ```/etc/passwd``` : 유저의 각종 정보 저장
	- ```/etc/shadow``` : 유저 패스워드를 암호화하여 저장
	- ```/etc/fstab``` : 시스템이 부팅될 떄 참고하는 마운트할 디바이스 테이블을 저장
	- ```/etc/hosts``` : 네트워크 호스트 이름과 IP 주소
	- ```/etc/rc.d/init.d``` 또는 ```/etc/init.d``` : 부팅시 시작할 여러가지 시스템 서비스 스크립트
	- ```/etc/resolv.conf``` : 시스템에서 외부로 접속할 떄 참고할 네임서버
	- ```/etc/sysconfig/i18n``` : 부팅시 언어셋 변수와 폰트 변수를 설정
	- ```/etc/sysconfig/iptables``` : 리눅스 방화벽 iptables 환경 설정
	- ```/etc/sysconfig/network``` : 부팅시 네트워크를 지우너할 것인지와 호스트명을 설정
	- ```/etc/sysconfig/network-scripts/ifcfg-eth0``` : 부팅시 사용할 첫 이더넷 카드의 정보 저장
- ```/bin```, ```/usr/bin``` : 실행 프로그램들. ```/bin```엔 기본적인 실행 프로그램, ```/usr/bin```엔 사용자들이 사용할 실행 프로그램
- ```/sbin```, ```/usr/sbin``` : 시스템 관리자를 위한 프로그램. 대부분 root를 위한 프로그램
- ```/usr``` :  사용자 애플리케이션을 지원하기 위한 다양한 파일이 위치
- ```/usr/local``` : 소프트웨어 설치시 또는 로컬머신에서 사용할 파일들이 위치. 소스파일을 기본 옵션으로 컴파일하면 ```/usr/local``` 디렉터리에 기본 설치가 되며 이 때 실행 파일은 ```/usr/local/bin```에 위치
- ```/var``` : 운영 중인 시스템의 변화를 체크할 수 있는 로그 파일들이 위치
	- ```/var/log``` : 로그 파일이 위치하는 디렉터리
	- ```/var/spool``` : 메일 메세지와 프린트 작업과 같이 프로세스를 위한 큐를 잡아놓기 위해 사용되는 디렉터리
- ```/lib``` : 공유 라이브러리 파일
- ```/home``` : 유저별 홈디렉터리가 존재하는 개인 홈디렉터리. ```useradd(adduser)``` 명령을 사용해 유저를 생성하면 ```"/home/유저아이디``` 형식으로 유저 홈디렉터리가 생성. 이때 기본적으로 생성되는 파일들은 ```/etc/skel``` 디렉터리 아래의 파일들임
- ```/tmp``` : 임시 파일들이 저장되는 디렉터리
- ```/dev``` : 리눅스 시스템에서 사용하는 디바이스 장치 파일들
- ```/proc``` : 이 디렉터리는 파일을 포함하지 않음. 현재 시스템 CPU 정보를 출력하기 위해 ```/proc/cpuinfo``` 파일을 출력
- ```/media```, ```/mnt``` : 마운트 포인트를 위해 사용되는 디렉터리
	- 마운트 : 디바이스 장치를 사용하기 위해 프로세스와 연결하는 것
	
## 입출력 리다이렉션과 파이프
### 표준 출력
- 표준 출력 : 결과를 모니터에 출력. 파일 디스크립터 숫자값으로 1로 표기
- ```>``` 문자를 사용해 표준 출력을 파일로 리다이렉션해 저장할 수 있음
	- ```ls > ls.txt```
- ```>>``` : 파일에 추가(append)할 경우 사용
	- ```cat test1.txt >> ls.txt```
- 만약 텍스트 파일의 내용을 모두 삭제하고 싶다면 ```/dev/null```로 읽어서 파일로 리다이렉션
	- ```cat /dev/null > lsls.txt```
- 표준 입력 - 키보드 : 파일 디스크립터 숫자로 0
- 표준 출력 - 모니터 : 파일 디스크립터 숫자로 1
- 표준 에러 - 모니터 : 파일 디스크립터 숫자로 2
- ```2>&1``` : 표준 출력이 전달되는 곳으로 표준 에러를 전달하는데, 마지막에 &를 사용해 현재 명령을 백그라운드로 실행 	
### 표준 입력
- 표준 입력 : 키보드로부터 데이터를 입력받는 것. 파일 디스크립터 숫자값으로 0
- 키보드를 대신해 파일로부터 입력을 받는 경우 ```<``` 문자를 사용
- ```sort < ls.txt```
- ```sort < ls.txt > sorted_lx.tst``` : ls.txt 파일의 정렬 결과를 sorted_ls.txt 파일로 저장한 다음 결과를 sorted_ls.txt로 저장

### 파이프
- ```|``` 문자를 사용해 두 명령어를 이어줌. 앞에서 실행한 명령의 결과값을 뒤에 적은 명령어의 입력으로 사용
- 즉, 파이프로 연결된 하나의 표준 출력을 다른 명령의 표준 입력으로 사용
- ```ls -lt | head```
- ```find . -type f -print | wc -l```
	
	
	
	
	
	
	
	
	
	 